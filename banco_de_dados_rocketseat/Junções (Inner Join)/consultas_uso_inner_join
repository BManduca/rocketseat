-- ##############################
-- Case e Filter
-- ##############################

-- Listar produto e nome da categoria correspondente
SELECT
    p.product_id,
    p.product_name,
    c.category_id,
    c.category_name
  FROM products AS p
  INNER JOIN categories AS c
    ON p.category_id = c.category_id
ORDER BY p.product_id;

-- Usando aliases curtos para simplificar colunas em ORDER BY
SELECT
    p.product_id AS pid,
    p.product_name AS nome_produto,
    c.category_id,
    c.category_name
FROM products AS p
INNER JOIN categories AS c
  ON p.category_id = c.category_id
WHERE p.price > 200
ORDER BY pid;


SELECT
    o.order_id,
    o.customer_id,
    c.first_name || ' ' || c.last_name as cliente,
    o.order_date,
    o.status,
    o.total_amount
FROM orders AS o
INNER JOIN customers AS c
  ON o.customer_id = c.customer_id      -- coluna 1: vincula pedido => cliente
  AND o.order_date >= c.created_at      -- coluna 2: garante que o pedido veio após a criação do cliente
ORDER BY o.order_date DESC
limit 20;


-- #########################################
-- Inner Join com Três ou Mais Tabelas
-- #########################################

-- criando um relatório chamado resumo de pedido
-- para esse relatorio é necessário:
  -- ter os dados do pedido (tabela orders)
  -- ter os dados do cliente (tabela customers)
  -- precisamos da descrição dos produtos (tabela products)
  -- informações detalhadas desses pedidos (tabela order_items)
SELECT
    o.order_id,
    o.order_date,
    c.first_name || ' ' || c.last_name AS cliente,
    c.city,
    p.product_name,
    oi.quantity,
    oi.unit_price,
    (oi.quantity * oi.unit_price) AS subtotal
FROM orders AS o
INNER JOIN customers AS c ON o.customer_id = c.customer_id
INNER JOIN order_items AS oi ON o.order_id = oi.order_id
INNER JOIN products AS p ON oi.product_id = p.product_id
WHERE o.status = 'DELIVERED';

-- mesma condição anterior, mas agora para pedidos que foram criados
-- entre 01/06/2024 a 31/08/2024

SELECT
    o.order_id,
    o.order_date,
    c.first_name || ' ' || c.last_name AS cliente,
    c.city,
    p.product_name,
    oi.quantity,
    oi.unit_price,
    (oi.quantity * oi.unit_price) AS subtotal
FROM orders AS o
INNER JOIN customers AS c ON o.customer_id = c.customer_id
INNER JOIN order_items AS oi ON o.order_id = oi.order_id
INNER JOIN products AS p ON oi.product_id = p.product_id
WHERE o.order_date BETWEEN '2024-06-01' AND '2024-08-31'
ORDER BY o.order_date DESC;



-- ######################################################
-- Seleção de Colunas Específicas e Uso de Distinct
-- ######################################################

-- bom evitar, pois, com relação ao INNER JOIN, será mostrado inumeras tabelas e isso é considerado muito
-- oneroso, podendo assim exigir demais o hardware, deixando a consulta mais lenta e pesada.
-- RUIM: SELECT *
-- MELHOR: 
SELECT c.first_name, c.last_name, o.order_date
  FROM customers AS c
  INNER JOIN orders AS o
    ON c.customer_id = o.customer_id;


-- DISTINCT => TRAZER DADOS QUE NÃO ESTEJAM DUPLICADOS
SELECT DISTINCT c.city
  FROM customers AS c
  INNER JOIN orders AS o ON c.customer_id = o.customer_id;


-- CONCATENAÇÃO
SELECT 
  CONCAT(c.first_name, ' ', c.last_name) AS nome_completo,
  TO_CHAR(o.order_date, 'DD/MM/YYYY') AS data_formatada
FROM customers AS c
INNER JOIN orders AS o ON c.customer_id = o.customer_id;


-- Listando o nome completo de cada cliente e quantos pedidos ele fez (sem duplicar linhas de cliente)
SELECT
  c.customer_id,
  CONCAT(c.first_name, ' ', c.last_name) AS cliente,
  COUNT(o.order_id) AS total_pedidos
FROM customers AS c
INNER JOIN orders AS o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name
ORDER BY total_pedidos DESC;

-- listar todas as cidades distintas de clientes que já fizeram pedidos
SELECT DISTINCT c.city
FROM customers AS c
INNER JOIN orders AS o
  ON c.customer_id = o.customer_id
ORDER BY c.city;

-- MOSTRAR DADOS DE PEDIDO COM NOME COMPLETO DO CLIENTE E DATA FORMATADA
SELECT
  o.order_id,
  CONCAT(c.first_name, ' ', c.last_name) AS nome_completo,
  TO_CHAR(o.order_date, 'DD/MM/YYYY') AS data_legivel
FROM orders AS o
INNER JOIN customers AS c
  on o.customer_id = c.customer_id
ORDER BY o.order_date DESC;


-- ####################
-- Uso do LEFT JOIN
-- ####################

SELECT ...
  FROM tabela_a AS a
  LEFT JOIN tabela_b AS b
    ON a.chave = b.chave;

SELECT
    p.product_id,
    p.product_name,
    oi.order_id
  FROM products AS p
  LEFT JOIN order_items AS oi
    ON p.product_id = oi.product_id;

SELECT
    p.product_id,
    p.product_name,
    oi.order_id,
    COUNT(oi.order_item_id) AS total_vendas
  FROM products AS p
  LEFT JOIN order_items AS oi
    ON p.product_id = oi.product_id
  GROUP BY p.product_id, p.product_name, oi.order_id
  ORDER BY total_vendas DESC;

-- Buscar todos os produtos  e que tenhya ligação com o order_items (itens adicionados ao pedidos)
SELECT
  p.product_id,
  p.product_name,
  oi.order_id
FROM products AS p
LEFT JOIN order_items AS oi
  ON p.product_id = oi.product_id
WHERE oi.order_item_id IS NULL
ORDER BY p.product_name;


-- ####################
-- Uso do RIGHT JOIN
-- ####################

SELECT ...
  FROM tabela_a AS a
  RIGHT JOIN tabela_b AS b
    ON a.chave = b.chave;

SELECT
  c.customer_id,
  CONCAT(c.first_name, ' ', c.last_name) AS nome_completo,
  o.order_id
FROM orders AS o
RIGHT JOIN customers AS c
  ON o.customer_id = c.customer_id;

-- ####################
-- Uso do FULL JOIN
-- ####################

-- BUSCAR TODOS OS PRODUTOS E TODAS AS CATEGORIAS MESMO
-- QUE NÃO HAJA CORREPONDÊNCIA ENTRE ELAS
SELECT
  p.product_id,
  p.product_name,
  c.category_id,
  c.category_name
FROM products AS p
FULL JOIN categories AS c
  ON p.category_id = c.category_id
ORDER BY c.category_id, p.product_id;

-- MOSTRAR TODOS OS PEDIDOS E TODOS OS CLIENTES,
-- MESMO QUE HAJA PEDIDOS SEM CLIENTE OU CLIENTES SEM PEDIDO.
SELECT
    o.order_id,
    o.customer_id AS pedido_customer_id,
    o.order_date,
    o.status,
    c.customer_id AS cliente_customer_id,
    c.first_name || ' ' || c.last_name AS cliente,
    c.city
FROM orders AS o
FULL JOIN customers AS c
  ON o.customer_id = c.customer_id
ORDER BY o.order_date DESC;

-- ##################################
-- Filtros Pós-Junção e Precedência
-- ##################################


SELECT *
  FROM products AS p
  LEFT JOIN order_items AS oi
    ON p.product_id = oi.product_id
  WHERE oi.quantity > 10;


-- CORRIGINDO A QUESTÃO ANTERIOR
SELECT *
  FROM products AS p
  LEFT JOIN order_items AS oi
    ON p.product_id = oi.product_id
  AND oi.quantity > 1;

-- REALIZANDO SUB-CONSULTAS
SELECT *
FROM (
  SELECT
    p.product_id,
    p.product_name,
    oi.order_id,
    oi.quantity
  FROM products AS p
  LEFT JOIN order_items AS oi
    ON p.product_id = oi.product_id
) AS subq
WHERE subq.quantity > 0 OR subq.quantity IS NULL;
